\documentclass{article}
\twocolumn
\usepackage{proof}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{automata,positioning}
\input{structure.tex} 

\title{Parsly: Procedureless Protocol Compiler\\
		\large A Software Engineering Approach to \\ Simplify Protocol Development Process} 

\author{Han Zheng\\ \texttt{tim.zheng@hivechat.org}} 
\date{ \today} 




\begin{document}
\maketitle 

\section{Introductions} % Unnumbered section
\subsection{The Cycle of Protocol Development}
\begin{figure}[h!]
\begin{center}
\label{fig:developmentCycle}
\begin{tikzpicture}[
	shorten >=1pt,
	node distance=2.5cm, 
	on grid, 
	auto, 
	scale=0.6, 
    transform shape, 
    align=center, 
    state/.style={
    	circle, 
    	draw, 
    	minimum size=1cm
    }] 
    
   \node[state,initial] (q_0)   {design}; 
   \node[state, right=of q_0] (q_1) {impl.}; 
   \node[state, right=of q_1] (q_2) {test}; 
   \node[state,accepting, right=of q_2](q_3) {deploy};
   \path[->] 
    (q_0) edge node {} (q_1)
    (q_1) edge node  {} (q_2)
    (q_1) edge [loop above] node {failure} (q_1)
    (q_2) edge node [swap] {sucess} (q_3) 
    (q_2) edge [bend left, below] node {failure} (q_1)
    (q_2) edge [bend left, below] node {} (q_0);
\end{tikzpicture}
\caption{development cycle}
\end{center}
\end{figure}

To better illustrate the process of protocol development, we divide it into four phases in a cycle: design, implement, test and deploy (see fig~\ref{fig:developmentCycle}). The devloper first need to design the message types and message fields of the protocol, and then implement the protocol with a programing language. Then the test phase comes, where the developer verifies that the implementation is correct. If the implementation is correct, the protocol is deployed, and the development can move on. Otherwise, the developer needs to go back and find out whether the problem lies in the design or the implementation. The implement phase usually turns out to be time consuming, as it involves noises like debugging and solving problems in the lower level protocols, like sticky packet of TCP.




\subsection{The Goal}

\begin{figure}[h!]
\begin{center}
\label{fig:newDevelopmentCycle}
\begin{tikzpicture}[
	shorten >=1pt,
	node distance=3cm, 
	on grid, 
	auto, 
	scale=0.6, 
    transform shape, 
    align=center, 
    state/.style={
    	circle, 
    	draw, 
    	minimum size=1cm
    }] 
    
   \node[state,initial] (q_0)   {design}; 
   \node[state, right=of q_0] (q_2) {compile \\ \& test}; 
   \node[state,accepting, right=of q_2](q_3) {deploy};
   \path[->] 
    (q_0) edge node {} (q_2)
    (q_2) edge node [swap] {sucess} (q_3) 
    (q_2) edge [bend left, below] node {failure} (q_0);
\end{tikzpicture}
\caption{new development cycle}
\end{center}
\end{figure}

Protocol compiler is a tool that helps automate the process of network protocol implementation. It compiles a network protocol discriptions in a domain specific language (DSL), which declares message types and message fields, to a target programing language, like C++, Java and Python. This has saved programmer considerable amount of time by helping them to skip the implementation step, where programmers are prone to problems like nullpointer crash, sticky packet, serialization, and so on. Therefore, protocol compiler simplifies the development cycle into three simple phases (see fig~\ref{fig:newDevelopmentCycle})




\section{Limitation of Current Methods}

There are several protocol compilers that exists. The most commonly used one is Google's \textit{Protocol Buffers} (also known as \textit{protobuf}). Protobuf takes in a protocol declaration in their DSL called \textit{proto3} (see fig~\ref{lst:proto3}) and generates the parsing logic in a popular collection of programing languages. During the runtime, \textit{protobuf} uses BSON, the binary representation of JavaScript Object Notation (JSON), to serialize and deserialise the messages. This has given programmers the convenience to handle the data by storing the message in JSON format.\\

However, there are several drawbacks in \textit{protobuf}. These drawbakcs mainly lies in the aspect of learning curve, performance, and correcness proving with formal verification.\\

First of all, although \textit{protobuf} has a well-designed DSL that concisely describes the protocol, it is one more language for the programer to learn and one more place to make mistakes. The programers need to read the documentations and do some practices in order to get started, which makes it harder to be used in fast-paced agile developent theme.\\

Speaking of performance, although \textit{protobuf} did a great job on space optimization by employing BSON for data serialization, BSON is not flexible enough for the users to tunne for optimization. We will talk about this in section~\ref{subsec:performanceAnalysis} \\

Moreover, when it comes to proof driven deveolpment, where, in order to prove the correctness of the implementation of the protocol, the developer needs to get the formal specification of the DSL. However, the specificaiton is not officially available, and even if it will be available in the future, it means more work for the developer, as there is one more layer of language to reason about. \\


\section{Parsly}
Therefore we introduce parsly, a protocol compiler that compiles protocol descriptions in JSON to C++ parsing logics. Parsley implements a serialization method that is similar to the BSON format but gives user more freedom of space optimizations. 

\label{subsec:performanceAnalysis}
\subsection{Performance Analysis}
According to the BSON's \href{http://bsonspec.org}{documentation}, BSON is designed to be efficient in space, but in some cases it uses even more space than JSON. BSON adds the length of strings and subobjects which makes traversal faster.

\begin{figure}[h!]
\label{eq:bsonGrammar}
\begin{align*}
\text{document} :=&  \text{int32 e\_list "\textbackslash x00" } \\
\text{e\_list} :=& \text{element e\_list} \\
&| \ \text{""} \\
\text{element}	:=& \text{"\textbackslash x01" e\_name double} \\
&| \ \text{"\textbackslash x02" e\_name string} \\
&| \ \text{"\textbackslash x03" e\_name document} \\
&| \ \text{"\textbackslash x04" e\_name document} \\
&| \ \text{"\textbackslash x05" e\_name binary} \\
&| \ \cdots \\
\text{string} :=& \text{int32 (byte*) "\textbackslash x00"} \\
\text{binary} :=& \text{int32 subtype (byte*)} \\
\text{subtype} :=& \text{"\textbackslash x00"} \\
&| \ \text{"\textbackslash x01"} \\
&| \ \text{"\textbackslash x02"} \\
&| \ \cdots 
\end{align*}
\caption{BSON standard v1.1 grammar}
\end{figure}

BSON uses 32-bit integer to indicate the length of the strings, binaries, as well as the whole document, and this is fixed by the specification (see fig~\ref{eq:bsonGrammar}). Therefore, no matter how long the string, binary or the document is, the length of the bytes that describes the data is fixed. This has left no space for user to optimize for space. For a message containing massive short strings, BSON will not perform well at all. 

\begin{figure}[h!]
\label{eq:parslyGrammar}
\begin{align*}
M :=& \phi \ \psi \\
\phi :=& \text{int8} \\
&| \ \text{int16} \\
&| \ \text{int32} \\
\psi :=& \text{element } \psi \\
&| \ \text{""} \\
\text{int} :=& \text{int8} \\
&| \ \text{int16} \\
&| \ \text{int32} \\
&| \ \text{int64} \\
&| \ \text{int128} \\
\text{binary} :=& \phi  \text{ (byte*)} \\
\text{element}	:=& \text{int} \\
&| \ \text{binary} 
\end{align*}
\caption{parsly serialization grammar}
\end{figure}

Parsly employs the same method for data serialization for performance, however, the length indicator size can be controlled by the user in the JSON description. This is achieved by extending the indicator $\phi$ to multiple sized data types like int8, int16 and int32, see fig~\ref{eq:parslyGrammar} (notice that parsly does not serialize the name of any data types).

\begin{figure}
\begin{center}
\lstset{language=c++}
\label{lst:proto3}
\begin{lstlisting}
message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
\end{lstlisting}
\caption{protocol described in proto3 language}
\end{center}
\end{figure}


\section{Analysis} % Unnumbered section


\section{Conclusion} % Unnumbered section

\end{document}
